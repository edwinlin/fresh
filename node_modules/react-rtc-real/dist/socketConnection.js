"use strict";

// we will need to add custom url to WS arg
// class SocketConnectionMethods {
// const async socketConnectionFunc = () => {
// check if it needs to be static
module.exports = {
  onMessage: function onMessage(parsedData, peerConnection, socketConnection, sessionConstraints) {
    var localUserStream, answer;
    return regeneratorRuntime.async(function onMessage$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            //  console.log('parsedData.type: ', parsedData.type)
            // console.log('receiving data from signaling server aka WebSockets', data);
            // const parsedData = JSON.parse(data.data);
            console.log('parsed data var', parsedData);
            _context.prev = 1;

            if (!parsedData.type) {
              _context.next = 32;
              break;
            }

            console.log('parsedData.type: ', parsedData.type);
            _context.t0 = parsedData.type;
            _context.next = _context.t0 === 'offer' ? 7 : _context.t0 === 'answer' ? 22 : _context.t0 === 'icecandidate' ? 26 : 29;
            break;

          case 7:
            console.log('Offer has been recieved');
            _context.next = 10;
            return regeneratorRuntime.awrap(peerConnection.setRemoteDescription(parsedData));

          case 10:
            _context.next = 12;
            return regeneratorRuntime.awrap(navigator.mediaDevices.getUserMedia(sessionConstraints));

          case 12:
            localUserStream = _context.sent;
            localUserStream.getTracks().forEach(function (track) {
              peerConnection.addTrack(track, localUserStream);
            });
            _context.next = 16;
            return regeneratorRuntime.awrap(peerConnection.createAnswer());

          case 16:
            answer = _context.sent;
            console.log('Answer is being created');
            _context.next = 20;
            return regeneratorRuntime.awrap(peerConnection.setLocalDescription(answer));

          case 20:
            socketConnection.send(JSON.stringify(peerConnection.localDescription));
            return _context.abrupt("break", 30);

          case 22:
            console.log('Answer has been recieved');
            _context.next = 25;
            return regeneratorRuntime.awrap(peerConnection.setRemoteDescription(parsedData));

          case 25:
            return _context.abrupt("break", 30);

          case 26:
            _context.next = 28;
            return regeneratorRuntime.awrap(peerConnection.addIceCandidate(parsedData.candidate));

          case 28:
            return _context.abrupt("break", 30);

          case 29:
            console.error('Unsupported SDP type');

          case 30:
            _context.next = 33;
            break;

          case 32:
            if (parsedData.text) {} // chatBox.innerHTML += `<li>${parsedData.text}</li>`;
            // console.log('hi user number ', userID);
            // else if (parsedData.userID) userID = parsedData.userID;


          case 33:
            _context.next = 38;
            break;

          case 35:
            _context.prev = 35;
            _context.t1 = _context["catch"](1);
            console.error('ERROR: ', _context.t1);

          case 38:
          case "end":
            return _context.stop();
        }
      }
    }, null, null, [[1, 35]]);
  } //    onMessage(data, peerConnection, socketConnection) {
  //     console.log('receiving data from signaling server aka WebSockets');
  //     const parsedData = JSON.parse(data);
  //     try {
  //       if (parsedData.type) {
  //         switch (parsedData.type) {
  //           case 'offer':
  //             console.log('Offer has been recieved');
  //             await peerConnection.setRemoteDescription(parsedData);
  //             const localUserStream = await navigator.mediaDevices.getUserMedia(
  //               sessionConstraints
  //             );
  //             localUserStream.getTracks().forEach(track => {
  //               peerConnection.addTrack(track, localUserStream);
  //             });
  //             const answer = await peerConnection.createAnswer();
  //             await peerConnection.setLocalDescription(answer);
  //             socketConnection.send(
  //               JSON.stringify(peerConnection.localDescription)
  //             );
  //             break;
  //           case 'answer':
  //             console.log('Answer has been recieved');
  //             await peerConnection.setRemoteDescription(parsedData);
  //             break;
  //           case 'icecandidate':
  //             await peerConnection.addIceCandidate(parsedData.candidate);
  //             break;
  //           default:
  //             console.error('Unsupported SDP type');
  //         }
  //       } else if (parsedData.text) {
  //         chatBox.innerHTML += `<li>${parsedData.text}</li>`;
  //         console.log('hi user number ', userID);
  //       } else if (parsedData.userID) userID = parsedData.userID;
  //     } catch (err) {
  //       console.error('ERROR: ', err);
  //     }
  //   }
  // }
  // export default onMessage;

};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9zb2NrZXRDb25uZWN0aW9uLmpzIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJvbk1lc3NhZ2UiLCJwYXJzZWREYXRhIiwicGVlckNvbm5lY3Rpb24iLCJzb2NrZXRDb25uZWN0aW9uIiwic2Vzc2lvbkNvbnN0cmFpbnRzIiwiY29uc29sZSIsImxvZyIsInR5cGUiLCJzZXRSZW1vdGVEZXNjcmlwdGlvbiIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImxvY2FsVXNlclN0cmVhbSIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsImFkZFRyYWNrIiwiY3JlYXRlQW5zd2VyIiwiYW5zd2VyIiwic2V0TG9jYWxEZXNjcmlwdGlvbiIsInNlbmQiLCJKU09OIiwic3RyaW5naWZ5IiwibG9jYWxEZXNjcmlwdGlvbiIsImFkZEljZUNhbmRpZGF0ZSIsImNhbmRpZGF0ZSIsImVycm9yIiwidGV4dCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBQSxNQUFNLENBQUNDLE9BQVAsR0FBaUI7QUFDZkMsRUFBQUEsU0FBUyxFQUFFLG1CQUNUQyxVQURTLEVBRVRDLGNBRlMsRUFHVEMsZ0JBSFMsRUFJVEMsa0JBSlM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTVQ7QUFDQTtBQUNBO0FBRUFDLFlBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLGlCQUFaLEVBQStCTCxVQUEvQjtBQVZTOztBQUFBLGlCQVlIQSxVQUFVLENBQUNNLElBWlI7QUFBQTtBQUFBO0FBQUE7O0FBYUxGLFlBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLG1CQUFaLEVBQWlDTCxVQUFVLENBQUNNLElBQTVDO0FBYkssMEJBY0dOLFVBQVUsQ0FBQ00sSUFkZDtBQUFBLDRDQWVFLE9BZkYsdUJBK0JFLFFBL0JGLHdCQW1DRSxjQW5DRjtBQUFBOztBQUFBO0FBZ0JERixZQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSx5QkFBWjtBQWhCQztBQUFBLDRDQWlCS0osY0FBYyxDQUFDTSxvQkFBZixDQUFvQ1AsVUFBcEMsQ0FqQkw7O0FBQUE7QUFBQTtBQUFBLDRDQWtCNkJRLFNBQVMsQ0FBQ0MsWUFBVixDQUF1QkMsWUFBdkIsQ0FDNUJQLGtCQUQ0QixDQWxCN0I7O0FBQUE7QUFrQktRLFlBQUFBLGVBbEJMO0FBcUJEQSxZQUFBQSxlQUFlLENBQUNDLFNBQWhCLEdBQTRCQyxPQUE1QixDQUFvQyxVQUFBQyxLQUFLLEVBQUk7QUFDM0NiLGNBQUFBLGNBQWMsQ0FBQ2MsUUFBZixDQUF3QkQsS0FBeEIsRUFBK0JILGVBQS9CO0FBQ0QsYUFGRDtBQXJCQztBQUFBLDRDQXdCb0JWLGNBQWMsQ0FBQ2UsWUFBZixFQXhCcEI7O0FBQUE7QUF3QktDLFlBQUFBLE1BeEJMO0FBeUJEYixZQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSx5QkFBWjtBQXpCQztBQUFBLDRDQTBCS0osY0FBYyxDQUFDaUIsbUJBQWYsQ0FBbUNELE1BQW5DLENBMUJMOztBQUFBO0FBMkJEZixZQUFBQSxnQkFBZ0IsQ0FBQ2lCLElBQWpCLENBQ0VDLElBQUksQ0FBQ0MsU0FBTCxDQUFlcEIsY0FBYyxDQUFDcUIsZ0JBQTlCLENBREY7QUEzQkM7O0FBQUE7QUFnQ0RsQixZQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSwwQkFBWjtBQWhDQztBQUFBLDRDQWlDS0osY0FBYyxDQUFDTSxvQkFBZixDQUFvQ1AsVUFBcEMsQ0FqQ0w7O0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUEsNENBb0NLQyxjQUFjLENBQUNzQixlQUFmLENBQStCdkIsVUFBVSxDQUFDd0IsU0FBMUMsQ0FwQ0w7O0FBQUE7QUFBQTs7QUFBQTtBQXVDRHBCLFlBQUFBLE9BQU8sQ0FBQ3FCLEtBQVIsQ0FBYyxzQkFBZDs7QUF2Q0M7QUFBQTtBQUFBOztBQUFBO0FBeUNBLGdCQUFJekIsVUFBVSxDQUFDMEIsSUFBZixFQUFxQixDQUczQixDQUhNLENBQ0w7QUFDQTtBQUVGOzs7QUE3Q087QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQStDUHRCLFlBQUFBLE9BQU8sQ0FBQ3FCLEtBQVIsQ0FBYyxTQUFkOztBQS9DTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQURJLENBbURmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBNUZlLENBQWpCIiwic291cmNlc0NvbnRlbnQiOlsiLy8gd2Ugd2lsbCBuZWVkIHRvIGFkZCBjdXN0b20gdXJsIHRvIFdTIGFyZ1xuXG4vLyBjbGFzcyBTb2NrZXRDb25uZWN0aW9uTWV0aG9kcyB7XG4vLyBjb25zdCBhc3luYyBzb2NrZXRDb25uZWN0aW9uRnVuYyA9ICgpID0+IHtcbi8vIGNoZWNrIGlmIGl0IG5lZWRzIHRvIGJlIHN0YXRpY1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9uTWVzc2FnZTogYXN5bmMgKFxuICAgIHBhcnNlZERhdGEsXG4gICAgcGVlckNvbm5lY3Rpb24sXG4gICAgc29ja2V0Q29ubmVjdGlvbixcbiAgICBzZXNzaW9uQ29uc3RyYWludHNcbiAgKSA9PiB7XG4gICAgLy8gIGNvbnNvbGUubG9nKCdwYXJzZWREYXRhLnR5cGU6ICcsIHBhcnNlZERhdGEudHlwZSlcbiAgICAvLyBjb25zb2xlLmxvZygncmVjZWl2aW5nIGRhdGEgZnJvbSBzaWduYWxpbmcgc2VydmVyIGFrYSBXZWJTb2NrZXRzJywgZGF0YSk7XG4gICAgLy8gY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2UoZGF0YS5kYXRhKTtcblxuICAgIGNvbnNvbGUubG9nKCdwYXJzZWQgZGF0YSB2YXInLCBwYXJzZWREYXRhKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHBhcnNlZERhdGEudHlwZSkge1xuICAgICAgICBjb25zb2xlLmxvZygncGFyc2VkRGF0YS50eXBlOiAnLCBwYXJzZWREYXRhLnR5cGUpO1xuICAgICAgICBzd2l0Y2ggKHBhcnNlZERhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ29mZmVyJzpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdPZmZlciBoYXMgYmVlbiByZWNpZXZlZCcpO1xuICAgICAgICAgICAgYXdhaXQgcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24ocGFyc2VkRGF0YSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFVzZXJTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShcbiAgICAgICAgICAgICAgc2Vzc2lvbkNvbnN0cmFpbnRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9jYWxVc2VyU3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgICAgICBwZWVyQ29ubmVjdGlvbi5hZGRUcmFjayh0cmFjaywgbG9jYWxVc2VyU3RyZWFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgcGVlckNvbm5lY3Rpb24uY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQW5zd2VyIGlzIGJlaW5nIGNyZWF0ZWQnKTtcbiAgICAgICAgICAgIGF3YWl0IHBlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHNvY2tldENvbm5lY3Rpb24uc2VuZChcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhbnN3ZXInOlxuICAgICAgICAgICAgY29uc29sZS5sb2coJ0Fuc3dlciBoYXMgYmVlbiByZWNpZXZlZCcpO1xuICAgICAgICAgICAgYXdhaXQgcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24ocGFyc2VkRGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdpY2VjYW5kaWRhdGUnOlxuICAgICAgICAgICAgYXdhaXQgcGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKHBhcnNlZERhdGEuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbnN1cHBvcnRlZCBTRFAgdHlwZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlZERhdGEudGV4dCkge1xuICAgICAgICAvLyBjaGF0Qm94LmlubmVySFRNTCArPSBgPGxpPiR7cGFyc2VkRGF0YS50ZXh0fTwvbGk+YDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2hpIHVzZXIgbnVtYmVyICcsIHVzZXJJRCk7XG4gICAgICB9XG4gICAgICAvLyBlbHNlIGlmIChwYXJzZWREYXRhLnVzZXJJRCkgdXNlcklEID0gcGFyc2VkRGF0YS51c2VySUQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFUlJPUjogJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gICAgb25NZXNzYWdlKGRhdGEsIHBlZXJDb25uZWN0aW9uLCBzb2NrZXRDb25uZWN0aW9uKSB7XG4gIC8vICAgICBjb25zb2xlLmxvZygncmVjZWl2aW5nIGRhdGEgZnJvbSBzaWduYWxpbmcgc2VydmVyIGFrYSBXZWJTb2NrZXRzJyk7XG4gIC8vICAgICBjb25zdCBwYXJzZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgLy8gICAgIHRyeSB7XG4gIC8vICAgICAgIGlmIChwYXJzZWREYXRhLnR5cGUpIHtcbiAgLy8gICAgICAgICBzd2l0Y2ggKHBhcnNlZERhdGEudHlwZSkge1xuICAvLyAgICAgICAgICAgY2FzZSAnb2ZmZXInOlxuICAvLyAgICAgICAgICAgICBjb25zb2xlLmxvZygnT2ZmZXIgaGFzIGJlZW4gcmVjaWV2ZWQnKTtcbiAgLy8gICAgICAgICAgICAgYXdhaXQgcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24ocGFyc2VkRGF0YSk7XG4gIC8vICAgICAgICAgICAgIGNvbnN0IGxvY2FsVXNlclN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKFxuICAvLyAgICAgICAgICAgICAgIHNlc3Npb25Db25zdHJhaW50c1xuICAvLyAgICAgICAgICAgICApO1xuICAvLyAgICAgICAgICAgICBsb2NhbFVzZXJTdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gIC8vICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24uYWRkVHJhY2sodHJhY2ssIGxvY2FsVXNlclN0cmVhbSk7XG4gIC8vICAgICAgICAgICAgIH0pO1xuICAvLyAgICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCBwZWVyQ29ubmVjdGlvbi5jcmVhdGVBbnN3ZXIoKTtcbiAgLy8gICAgICAgICAgICAgYXdhaXQgcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAvLyAgICAgICAgICAgICBzb2NrZXRDb25uZWN0aW9uLnNlbmQoXG4gIC8vICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkocGVlckNvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbilcbiAgLy8gICAgICAgICAgICAgKTtcbiAgLy8gICAgICAgICAgICAgYnJlYWs7XG4gIC8vICAgICAgICAgICBjYXNlICdhbnN3ZXInOlxuICAvLyAgICAgICAgICAgICBjb25zb2xlLmxvZygnQW5zd2VyIGhhcyBiZWVuIHJlY2lldmVkJyk7XG4gIC8vICAgICAgICAgICAgIGF3YWl0IHBlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKHBhcnNlZERhdGEpO1xuICAvLyAgICAgICAgICAgICBicmVhaztcbiAgLy8gICAgICAgICAgIGNhc2UgJ2ljZWNhbmRpZGF0ZSc6XG4gIC8vICAgICAgICAgICAgIGF3YWl0IHBlZXJDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShwYXJzZWREYXRhLmNhbmRpZGF0ZSk7XG4gIC8vICAgICAgICAgICAgIGJyZWFrO1xuICAvLyAgICAgICAgICAgZGVmYXVsdDpcbiAgLy8gICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5zdXBwb3J0ZWQgU0RQIHR5cGUnKTtcbiAgLy8gICAgICAgICB9XG4gIC8vICAgICAgIH0gZWxzZSBpZiAocGFyc2VkRGF0YS50ZXh0KSB7XG4gIC8vICAgICAgICAgY2hhdEJveC5pbm5lckhUTUwgKz0gYDxsaT4ke3BhcnNlZERhdGEudGV4dH08L2xpPmA7XG4gIC8vICAgICAgICAgY29uc29sZS5sb2coJ2hpIHVzZXIgbnVtYmVyICcsIHVzZXJJRCk7XG4gIC8vICAgICAgIH0gZWxzZSBpZiAocGFyc2VkRGF0YS51c2VySUQpIHVzZXJJRCA9IHBhcnNlZERhdGEudXNlcklEO1xuICAvLyAgICAgfSBjYXRjaCAoZXJyKSB7XG4gIC8vICAgICAgIGNvbnNvbGUuZXJyb3IoJ0VSUk9SOiAnLCBlcnIpO1xuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIC8vIGV4cG9ydCBkZWZhdWx0IG9uTWVzc2FnZTtcbn07XG4iXX0=